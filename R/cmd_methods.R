#' @name generate_command_spec
#'
#' @return A data frame of sub-commands with name, description, functions
#'     invoked and type
generate_command_spec <- function() {
    command_spec <- data.frame(
        name = c(
            'create',
            'preprocess',
            'reduceDim',
            'partition',
            'topMarkers',
            'learnGraph',
            'orderCells',
            'diffExp',
            'plotCells'
        ),
        description = c(
            'Creation of Monocle 3 object from expression and metadata.',
            'Normalisation, scaling, initial dimension reduction.',
            'Reduce dimensionality by UMAP.',
            'Partition cells into groups.',
            'Get top markers for each groups',
            'Learn trajectories.',
            'Adjust the start of pseudo-time',
            'Identify genes with varing expression along trajectories.',
            'Visualise trajectories.'
        ),
        functions = c(
            'createCDS',
            'preprocessCDS',
            'reduceDimension',
            'partitionCells',
            'topMarkers',
            'learnGraph',
            'orderCells,get_root_principal_nodes',
            'principalGraphTest',
            'plot_cell_trajectory'
        ),
        type = c('o','io', 'io', 'io', 'it', 'io', 'io', 'it', 'ip'),
        stringsAsFactors = FALSE
    )
    rownames(command_spec) <- command_spec$name
    command_spec
}

#' @name generate_command_usage
#'
#' @param command_spec sub-command specification table generated by
#'     generate_command_spec()
#' @return Formatted usage text for the master command
generate_command_usage <- function(command_spec) {
    usage <- paste(
        'Usage: monocle3 [-h] <command> ...',
        '',
        'Commands:',
        paste(
            sprintf('  %-17s %-60s', command_spec$name, command_spec$description),
            collapse = '\n'
        ),
        '',
        'Options:',
        sprintf('  %-17s %-60s', '-h, --help', 'Show this help message and exit'),
        sep = '\n'
    )
}

#' Prepend function option names with function name, add options of common
#' functions according to command type
prepare_option_spec <- function(cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    fn_options <- function_options(cmd_functions)
    for (i in seq_along(fn_options)) {
        fn_name <- cmd_functions[i]
        for (j in seq_along(fn_options[[i]])) {
            dest <- fn_options[[i]][[j]]@dest
            fn_options[[i]][[j]]@dest <- paste(fn_name, dest, sep = '___')
        }
    }
    option_spec <- do.call('c', fn_options)
    if (grepl('p', cmd_spec$type)) option_spec <- c(output_plot_options(), option_spec)
    if (grepl('t', cmd_spec$type)) option_spec <- c(output_table_options(), option_spec)
    if (grepl('o', cmd_spec$type)) option_spec <- c(output_object_options(), option_spec)
    if (grepl('i', cmd_spec$type)) option_spec <- c(input_options(), option_spec)
    option_spec <- c(option_spec, common_options())
}

#' Remove function name prefix from parsed option names, aggregate options from
#' the same function into separate lists
prepare_parsed_options <- function(opts, cmd_spec) {
    cmd_functions <- unlist(strsplit(cmd_spec$functions, ','))
    new_opts <- list()
    for (fn_name in cmd_functions) {
        fn_prfx <- paste0('^', fn_name, '___')
        k <- grep(fn_prfx, names(opts))
        names(opts)[k] <- sub(fn_prfx, '', names(opts)[k])
        new_opts[[paste0(fn_name, '_options')]] <- opts[k]
        opts[k] <- NULL
    }
    opts$help <- NULL
    c(opts, new_opts)
}

#' @name monocle_create
#'
monocle_create <- function(
    output_object,
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    createCDS_options = list()
) {

    if (is.null(createCDS_options[['expression_matrix']])) {
        message('You need to provide the expression matrix by --expression-matrix. Aborting.')
        q(save = 'no', status = 1)
    }
    #helper variable for dimension compatibility check later
    #a newly imported TSV/CSV's dimension 1 is compared against the count matrix dimension...?
    dims <- list()
    #introduces less logic downstream to just have it check itself
    dims[['expression_matrix']] <- 1
    dims[['cell_metadata']] <- 2
    dims[['gene_annotation']] <- 1

    #the three constituents of the new_cell_data_set() call
    #are passed as arguments to the function, and live in this list
    for (var in c('expression_matrix','cell_metadata', 'gene_annotation')) {
        file <- createCDS_options[[var]]
        if (is.null(file)) {
            assign(var, NULL)
        } else {
            if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'RDS') {
                assign(var, readRDS(file))
            } else if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'MTX') {
                assign(var, Matrix::readMM(file))
            } else {
                #select correct delimiter for tsv or csv file
                sep <- ','
                if (toupper(substr(file, nchar(file)-2, nchar(file))) == 'TSV') sep <- '\t'
                assign(
                    var,
                    as.matrix(read.delim(
                        file, sep = sep, row.names = 1, stringsAsFactors = FALSE, check.names = FALSE
                    ))
                )
                #dimensionality check to account for the possible lack of a header
                if (dim(get(var))[1] != dim(expression_matrix)[dims[[var]]]) {
                    if (dim(get(var))[1] == dim(expression_matrix)[dims[[var]]] - 1) {
                        assign(
                            var, as.matrix(read.delim(
                                     file, sep = sep, row.names = 1, header = FALSE, stringsAsFactors = FALSE
                                 ))
                        )
                    } else {
                        message(paste('Dimensionality mismatch between',file,'and expression matrix. Exiting'))
                        q(save = 'no', status = 1)
                    }
                }
            }
        }
    }

    #a bit of 10x compatibility - the genes/features tsv file does not come with column names
    #generate some automatic column names
    if (!is.null(createCDS_options[['gene_annotation']])) {
        if (basename(createCDS_options[['gene_annotation']]) == 'genes.tsv')
            colnames(gene_annotation) <- c('gene_short_name')
        if (basename(createCDS_options[['gene_annotation']]) == 'features.tsv')
            colnames(gene_annotation) <- c('gene_short_name', 'feature_type')
    }

    cds <- new_cell_data_set(
        expression_matrix,
        cell_metadata = cell_metadata,
        gene_metadata = gene_annotation
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_preprocess
#'
#' @importFrom BiocGeneric estimateSizeFactors estimateDispersions
#' @importFrom monocle3 preprocess_cds
monocle_preprocess <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    preprocessCDS_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

	#the current (08.08.19) monocle3 tutorial doesn't do this anymore, so commenting out
    #cds <- estimateSizeFactors(cds)
    #cds <- estimateDispersions(cds)

    cds <- do.call(
        'preprocess_cds',
        c(list(cds, verbose = verbose), preprocessCDS_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_reduceDim
#'
#' @importFrom monocle3 reduce_dimension
monocle_reduceDim <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    reduceDimension_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'reduce_dimension',
        c(list(cds, verbose = verbose), reduceDimension_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_partition
#'
#' @importFrom monocle3 cluster_cells
monocle_partition <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    partitionCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'cluster_cells',
        c(list(cds, verbose = verbose), partitionCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_learnGraph
#'
#' @importFrom monocle3 learn_graph
monocle_learnGraph <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    learnGraph_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    learn_graph_control <- list()
    for (opt in c(
            'euclidean_distance_ratio',
            'geodesic_distance_ratio',
            'minimal_branch_len',
            'orthogonal_proj_tip',
            'prune_graph')
    ) {
        learn_graph_control[[opt]] <- learnGraph_options[[opt]]
        learnGraph_options[[opt]] <- NULL
    }

    cds <- do.call(
        'learn_graph',
        c(list(cds, verbose = verbose, learn_graph_control = learn_graph_control),
          learnGraph_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_orderCells
#'
#' @importFrom monocle3 order_cells
monocle_orderCells <- function(
    input_object,
    output_object,
    input_object_format = 'cds3',
    output_object_format = 'cds3',
    introspective = FALSE,
    verbose = FALSE,
    get_root_principal_nodes_options = list(),
    orderCells_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    if (is.null(orderCells_options$root_pr_nodes) &&
        is.null(orderCells_options$root_cells)) {
        orderCells_options$root_pr_nodes <- do.call(
            'get_root_principal_nodes',
            c(list(cds), get_root_principal_nodes_options)
        )
    }

    cds <- do.call(
        'order_cells',
        c(list(cds, verbose = verbose), orderCells_options)
    )

    monocle_write_obj(cds, output_object, output_object_format, introspective)
}

#' @name monocle_diffExp
#'
#' @importFrom monocle3 graph_test
monocle_diffExp <- function(
    input_object,
    output_table,
    input_object_format = 'cds3',
    output_table_format = 'tsv',
    introspective = FALSE,
    verbose = FALSE,
    principalGraphTest_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    cds <- do.call(
        'graph_test',
        c(list(cds, verbose = verbose), principalGraphTest_options)
    )

    monocle_write_table(cds, output_table, output_table_format, introspective)
}

#' @name monocle_plotCells
#'
#' @importFrom monocle3 plot_cells
monocle_plotCells <- function(
    input_object,
    output_plot,
    input_object_format = 'cds3',
    output_plot_format = 'png',
    verbose = FALSE,
    plot_cell_trajectory_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    p <- do.call(
        'plot_cells',
        c(list(cds), plot_cell_trajectory_options)
    )

    monocle_write_plot(p, output_plot, output_plot_format)
}

#' @name monocle_topMarkers
#'
#' @importFrom monocle3 top_markers plot_genes_by_group
#' @importFrom dplyr arrange top_n group_by filter pull

monocle_topMarkers <- function(
    input_object,
    output_table,
    input_object_format = 'cds3',
    output_table_format = 'tsv',
    introspective = FALSE,
    verbose = FALSE,
    topMarkers_options = list()
) {
    cds <- monocle_read_obj(input_object, input_object_format)

    # reference_cells can be a list or a number
    # if it is a list, it will come as a comma separated enumeration
    # of cell identifiers as available in
    # colnames(cds).

    reference_cells <- topMarkers_options[['reference_cells']]
    if (!is.null(reference_cells)) {
        if (!is.na(as.integer(reference_cells))) {
            topMarkers_options[['reference_cells']] <- as.integer(reference_cells)
        } else {
            reference_cells <- unlist(strsplit(reference_cells, ','))
            topMarkers_options[['reference_cells']] <- reference_cells[reference_cells %in% colnames(cds)]
        }
    }

    for (v in c('filter_fraction_expression', 'top_n_markers', 'plot_top_markers', 'save_full_markers')) {
        assign(v, topMarkers_options[[v]])
        topMarkers_options[[v]] <- NULL
    }

    marker_test_res <- do.call(
        'top_markers',
        c(list(cds, verbose = verbose), topMarkers_options)
    )

    if (topMarkers_options[['marker_sig_test']]) {
        top_marker_test_res <- arrange(top_n(group_by(filter(
            marker_test_res, fraction_expressing >= filter_fraction_expression
        ), cell_group), top_n_markers, pseudo_R2), cell_group)
    } else {
        top_marker_test_res <- arrange(top_n(group_by(filter(
            marker_test_res, fraction_expressing >= filter_fraction_expression
        ), cell_group), top_n_markers, marker_score), cell_group)
    }

    monocle_write_table(top_marker_test_res, output_table, output_table_format, introspective)

    if (!is.null(plot_top_markers)) {
        output_plot_format <- ifelse(grepl('[.]pdf$', plot_top_markers), 'pdf', 'png')
        top_marker_ids <- unique(pull(top_marker_test_res, gene_id))
        p <- plot_genes_by_group(
            cds,
            top_marker_ids,
            group_cells_by = topMarkers_options[['group_cells_by']],
            ordering_type = ifelse(top_n_markers==1, 'maximal_on_diag', 'cluster_row_col'),
            axis_order = 'group_marker',
            max.size = 3
        )
        monocle_write_plot(p, plot_top_markers, output_plot_format)
    }

    if (!is.null(save_full_markers)) {
        full_table_format <- ifelse(grepl('[.]csv$', save_full_markers), 'csv', 'tsv')
        monocle_write_table(marker_test_res, save_full_markers, full_table_format)
    }
}
